#include<iostream>
#include<functional>// (c 보이드 포인터와 같음)

using namespace std;


#pragma region 포인터
/*


▶ 포인터란?


- 어떠한 값을 저장하는게 아닌 어떠한 값의 주소(Address)를 저장하는 것
- 메모리의 주소를 의미하며 c/c++ 언어는 포인터를 통해서 데이터 (변수)에 간접적으로 접근하는것이 가능하다.ㅣ
- 포인터를 활용하면 서로 다른 영역에 있는 변수라 하더라도 값을 변경하는 것이 가능

※ 심플하게 기억할 3가지
ㄴ 어떠한 값의 주소: 해당 값이 저장된 컴퓨터 메모리상의 주소
ㄴ ★  * : 해당 메모리에 있는 데이터 값을 가져오는 기능을 한다.
ㄴ&: 주소값을 반환하는 연산자

※ 포인터: 가르키는 놈, 주소를 담는 그릇 
ㄴ 3가지: *, ->, 주소 


※ 기본적으로 프로그래머는 안전성을 위해서 마음대로 메모리상의 어떤 위치든 접근하는것을 허용하지 않는다. (불가능)

※ 변수의 할당을 통해 메모리의 사용 권한이 주어진 위치만 포인터를 통해서 조작하는것이 가능하다.

▷ c/c++언어 포인터에 자료형이 필요한 경우

- 포인터는 단순히 메모리의 주소에 불가하기 때문에 해당 정보만을 가지고는 
메모리의 얼마만큼의 크기로 값을 저장하거나 읽어들일지 판단하는것이 불가하다.

- 그렇기 때문에 포인터의 자료형을 통해서 저장 및 읽어들일 메모리의 크기를 명시해 줘야 한다. 고로 포인터와 해당 포인터에 저장할 변수의 자료형은 
일처해야한다.

- 단 메모리의 주소만을 보관하고 싶다면 특정 자료형을 명시하는 것이 아니라 void* 형으로 선언하는 것이 가능하다
ㄴ 해당 포인터를 보이드 포인터라고 부르며 보이드 포인터는 어떠한 자료형의 메모리 주소도 보관하는 것이 가능하다.


EX: 
int nValue = 0;
float fValue = 0.0f;
double dbValue = 0.0;

int *pnValue = &nValue;
float *pfValue = &fValue
double &pdbValue = &fValue

※ 포인터는 메모리의 주소를 보관하는 역활을 하기 때문에 포인터의 크기는 모두 동일하다


▷ 함수의 종류
Call by nalue
ㄴ 값의 전달(Date)
ㄴ int Add(int a, int b)

Call by Reference
ㄴ주소값의 전달(Address)
 ㄴ int Add(int*a, int* b)




*/
#pragma endregion 


void LinePrint()
{

	cout << "===========================" << endl;
}


void main()
{

	cout << "포인터" << endl;
	LinePrint();

	/*
	
	-C/C++ 언어의 포인터 선언 방법
	int nValue = 0;    <- 메모리의 특정 영역에 4바이트 공간 할당
	int *pnpointer = &Value <- nValue 할당 된 메모리 공간의 첫 주소 할당
	*/
	
	int valueA = 10;
	int* pValueA = &valueA; // (자료형 옆에 * 는 포인터 선언)
	int** ppValueA = &valueA;
	// 주소값
	cout << ppValueA << endl;
	// 10
	cout << *(*ppValueA) << endl; //(변수이름 옆에 *는 참조)// 참조는 안에 들어간 값을 보겟다는 뜻
	// 주소값
	cout << "valueA의 주소:" << &valueA  << endl;
	
	// 변수
   cout << valueA; << endl; 
	
	cout << pvalueA; << endl; // 벨류a 주소
	
	cout << *pvalueA; << endl;// 참조이니 안에있는걸보겠다 안에있는건  10 <- 10을 봄


	LinePrint();

	int valueB = 3;
	// 요주의 선언과 동시에 할당해야함

	int* pValueB;

	cout << valueB << endl;
	cout << &valueB << endl;
	pValueB = &valueB

	cout << pValueB << endl;
	
	cout << *pValueB << endl;
	cout << &pValueB << endl;
/*

- 포인터를 초기화 하지 않고 값을 바꾸면.....


EX: 
int* pVauleC;
pVauleC = 100;

pVauleC를  초기화 하지 않았다면 pVauleC는 쓰레기 값을 가지고 있는데 이 값은 어디에서 쓰이고 있는 값일수도 있다.

- 빈 자리였다면 다행이지만 아니였다면 쓰이는 값이 변경되는 것이므로 치명적 오류 발생
- 그래서 포인터가 가르키고 있는 값을 변경할때는 반드시 확인하고 예외처리 이후 변경을 시도한다.

*/
	int* pValueC = NULL;
	
	//NULL, nullptr의 의미는 현재 포인터가 아무런 메모리 위치도 가르키고 있지 않다는 뜻을 지니고 있다(즉, 포인터를 초기화 하는데 주로 활용된다.
	/*
	
	-NULL은 엄밀히 말하면 포인터가 아니라 매크로에서 정의된 상수 0
	※NULL 동작 방식
	  ㄴ C++에서는  NULL = 0  c++에서는 nullptr
	  ㄴ C에서는 void*로 치환해서 사용한다 c쪽언어는 NULL
	
	
	※ 결론 : NULL은 진짜 널을 가리키는 포인터가 아니라 숫자 0을 의미한다.
	
	
	
	*/
	pValueC = &valueB
		if (pValueC != nullptr)
		{
			*pValueC = 30; // (참조로 들어가서 안의 값을 바꿈)

		}

	LinePrint();
	cout << " 다중포인터" << endl;
	int valueC = 5;
	int* pValueD = &valueC;
	int** ppValueB = &pvalueD;
	int*** pppValueA = &ppvalueB;


	cout << ValueC << endl;
	cout << pValueD<< endl;
	cout << ppValueB << endl;
	cout << &valueC << endl;
	cout << pvalueD << endl;
	cout << ppvalueB << endl;
	cout << &ValueC << endl;
	cout << &pValueD << endl;
	cout << &ppValueB << endl;
	cout << *pvalueD << endl;
	cout << *ppvalueB << endl;
	cout << **ppvalueB << endl;

	/*
▶ 동적 할당

- 컴퓨터는 다양한 메모리의 구성영역을 가진다.

※ c/c++ 면접 관련 핵 필살 질문
▷ 코드 영역

- 실행할 코드가 저장되는 메모리 공간이며 CPU는 코드영역에 저장된 명령문들을 하나씩 가져가서 실행한다.

- 코드영역은 기본적으로 운영체제에 의해서 관리되기 때문에 직접적으로 제어하는것은 불가능하다.(뚫다보면 가능하긴함 근데 힘듬 오래걸리기도하고)

▷ 데이터 영역

- 전역 변수와 static으로 선언되는 static 변수가 할당되는 공간
- 프로그램 시작과 동시에 메모리 공간에 할당되어 프로그램 종료시까지 남아있다.(전역)
- 전역 변수, 정적변수등 프로그램이 실행 될때 할당이 되고 종료될때 제거되는 영역이라고 할 수 있다.


▷ 스택 영역(구성을 아는것이 중요)

- 지역변수와 매개변수가 할당, 선언된 함수를 빠져나가면 소멸
- 시스템에 의해서 관리되는 영역

(탑처럼 main 위로 줄줄히 쌓임)
(특징 선입 후출)
(반환주소를 컴파일러에 던져서 컴파일러가 읽음)
(스택의 최대 사이즈? 약 1mb)
(스택 오버플로우: 스택의 공간이 넘칠경우 발생함)


▷ 힙 영역(동적메모리)(어떻게 쓰는지 아는것이 중요)
	

- 프로그래머에 의해서 관리되는 영역

- 데이터 영역과 스택영역에 할당되는 변수들은 생성과 소멸 주기가 정해져 있다.

- 하지만 프로그래머가 원하는 시점에 변수를 할당하고 소멸할 수 있는 영역이 바로 힙

- 특징으로는 프로그래머가 직접 할당을 하기 때문에 프로그래머가 직접 소멸을 시켜야 한다.

- 삭제를 해주지 않으면 메모리에 계속 상주한다.(메모리릭(메모리가 계속 남아있음), 댕글링 포인터(삭제된 개체를 가리키고 있음 프로그램 날라가거나(메모리 자체가 날라간경우  이상한값가져와서 연산됨(안에 데이터만 날라간경우))
   ㄴ 프로그램이 종료될때 소멸을 시켜주긴 한다.

   ================================================================

  ▶동적 할당(Dynamic Allocation)


  - 프로그램을 작성할때 (컴파일 타임 or 디자인 타임) 메모리 필요량을 지정하는 정적 할당과는 달리 실행중에(런타임) 필요한 만큼의 메모리를 할당하는 기법

  - 동적할당된 메모리는 이름이 없는 변수라고 할 수 있다.

  - 점적인 메모리 영역을 차지하고 있으므로 일단 값을 기억할수 있지만 이름이 없으므로 오로지 "포인터"로만 접근할 수 있다.

- 동적할당시 주의점
ㄴ동적할당을 해두면 메모리에 올려진 상태로 유지된다.
 ㄴ 때문에 동적할당을 해놓고 사용이 끝나면 반드시 파괴해야한다.
 
 동적할당을 사용하는 이유
 ㄴ 우리 게임 같은 경우에는 게임을 만들다 보면 지역변수도 아니고 전역변수도 아닌 변수가 필요한 경우가 있다.
    ㄴ ex: 함수가 매번 호출될 때마다 새롭게 할당되고 또 함수를 빠져나가도 유지되는 변수
	ㄴ 지역변수를 쓰자니 함수가 끝나면 소멸이 되고, 전역변수를 쓰자니 이전의 값을 덮어버리기 때문에 원하는 결과를 얻을 수 없다.

	ㄴ 만약 최대 100개의 데이터를 저장해야 할때 우리는 정적으로 100개를 할당해야 하지만
	40개의 데이터 밖에 들어오지 않는다면 60개가 낭비되는 상황 발생

	ㄴ 그래서 메모리 관리를 위해 들어오는 족족 할당하겠다 -> 동적할당


	- 동적 할당

	c/c++ 언어의 메모리 동적 할당 방법
	-malloc( c언어의 동적할당 방법)
	-new    (c++언어의 동적할당 방법)


	동적 할당시 주의점
	1. 메모리 릭
	2. 댕글링 포인터



*/


	// new: 동적할당 키워드(문법)
	int* coutA = new int[3];
	int* coutB = new int;

	for (int i = 0; i < 3; i++)
	{
		coutA[i] = i;
			*coutB = i + 18;
	}


	for (int i = 0; i < 3; i++)
	{


		cout << "카운트:" << coutA[i] << endl;
 
	}


	cout << "카운트 2번:" << coutB << endl;

	// 파괴한다
	delete[] coutA; // 배열로 파괴
	delete coutB;

	// 보이드 포인터(C) #include<functional>(c++)
	// 포인터 연산                                관심있으면 찾아보도록 하자 !




}