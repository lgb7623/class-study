#pragma once
#include<iostream>

using namespace std;




#pragma region 상속
/*

▶ 상속에서 객체지향 프로그래밍의 3대 요소



- 상속
- 다형성
- 캡슐화


▷ 상속이란?

- 기존클래스가 지니고 있는 멤버 변수 또는 멤버 함수를 이어 받아 새로운 기능을 확장하는 것을 의미한다.

- 상속을 이용하면 중복적으로 발생하는 기능 또는 속성을 하나의 클래스에 선언 후 
해당 클래스를 계속 재사용 하는것이 가능하다.

▷ 올바른 상속 관계를 나타내는(만들어 내는) 규칙

-is a의 관계  (특정 클래스가 또 다른 클래스의 모습으로 허용 될 경우)
-has a의 관계 (특정 클래스가 또 다른 클래스로 포함이 허용 될 경우)

EX:
- 인간은 학생이다.
- 학생은 인간이다.


-위의 예시처럼 학생은 인간이기도 하기 때문에 is a의 관계가 성립된다.
ㄴ 말인즉슨 학생 클래스가 인간 클래스를 상속한다면 이는 올바른 구조를 뜻한다.


▷ 상속 문법

class 파생 클래스(자식) : 접근 제어 지시자(지정자) 기본 클래스(부모)


private 상속:
ㄴ 기본클래스를 private로 상속받으면 기본 클래스의 protected,public 멤버들은 모두 파생 클래스의 private 멤버로 상속 확장이 된다.

public 상속: (대부분임)
ㄴ 기본 클래스를 public으로 상속 받으면 기본 클래스의 proteced, public 멤보들은 접근지정 변경 없이 파생클래스의 public 멤버로 확장된다.

proteced 상속
ㄴ 기본 클래스를 protected로 상속 받으면 기본 클래스의 proteced, public 멤버들은 모두 파생 클래스의 proteced 멤버로 상속 확장된다.

(상속은 상위 부모클래스가 사라지면 하위 클래스가 기능을 잃기 때문에 디자인페턴(관찰자(옵저버가 하위 클래스를 처리해줌))을 활용하는 경우가 많다)


*/
#pragma endregion 



class unit
{

private:

	//! do nothing
protected:
	char* name;
	int hp;
	int mp;
	int atk;
	bool die;

public:
	/*
    함수 오버로딩(중복정의 <=> 재정의(오버라이딩))

	- c++ 언어는 동일한 이름의 함수라 하더라도 입력 매개변수가 서로 다르다면
	별게의 함술고 인지하는 기능을 제공한다.


	- 해당 기능을 함수 오버로딩이라고 지칭한다.

    - 함수 오버로딩의 규칙은 입력 매개변수만으로 구분하기 때문에 함수의 반환형이 다르다
    하더라도 이는 함수 오버로딩 규칙에 성립되지 않는다.



	1. 기존에 만들어 놓은 함수와 이름은 같지만 인수의 형태가 다른 함수
	2. 인수 형태는 같은데 반환값만 다른 경우는 모호한 에러 발생
	3. 주로 같은 클래스내의 멤버 함수간 발생한다.
	(오버로딩 변환규칙 한번은 꼭 읽어보는것이 좋음)
	*/

	void attack(char* myname, char* enemyname);
	void attack(int atk, int enemyhp);
	void attack(bool* enemydie);
	// 스킬
	virtual void attack();
	
	//(버추얼 붙으면 가상함수) 재정의가 가능해짐 


	unit();
	~unit();
};

